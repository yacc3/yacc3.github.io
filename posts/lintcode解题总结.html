

<!DOCTYPE html  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
  <head>
    <meta charset="utf-8">
    <title>lintcode解题总结</title>
    
    <meta name="author" content="yacc3">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="/css/syntax.css" rel="stylesheet" type="text/css" media="all">
    <link href="/css/bootstrap.2.2.2.min.css" rel="stylesheet" type="text/css" media="all">
    <link href="/css/style.css" rel="stylesheet" type="text/css" media="all">
    
  <script type="text/javascript" src="/js/jquery.min.js"></script>
  <script type="text/javascript" src="/js/bootstrap.min.js"></script>
  <script type="text/javascript" src="/js/jquery.tocLight.js"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [ ['$[',']$'] ]}
    });
  </script>
    <link href="" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

  </head>

  <body>
    <div class="navbar">
      <div class="navbar-inner">
        <div class="container-narrow">
          <a class="brand" href="/">yacc3</a>
          <ul class="nav">
            <li><a href="/explore.html">Explore</a></li>
            <li><a href="/categories.html">Category</a></li>
            <li><a href="/tags.html">Tag</a></li>
            <li><a href="/archive.html">Archive</a></li>
            <li><a href="/about.html">About</a></li>

<!--             <li><a href="https://github.com/yaccai">Github</a></li> -->
          </ul>
        </div>
      </div>
    </div>

    <div class="container-narrow">

      <div class="content">
        

<div class="page-header">
  <h11>lintcode解题总结 </h11>
</div>

<div class="row-fluid post-full">
  <div class="span12">


    <div class="date">
        <span>2016-07-15 </span>
    </div>
    <div class="content">
        <div id="toc-container">
  <table class="toc" id="toc">
    <tbody>
      <tr>
        <td>
          <div id="toctitle">
            <h2>Contents</h2>
          </div>
          <ul>
            <li class="toc_level-1 toc_section-1">
              <a href="#tocAnchor-1-1"><span class="tocnumber">1</span> <span class="toctext">统计数组中的出现次数最多的数字</span></a>
              <ul>
                <li class="toc_level-2 toc_section-2">
                  <a href="#tocAnchor-1-1-1"><span class="tocnumber">1.1</span> <span class="toctext">如果没有限制，只是找出次数最多的数字？</span></a>
                </li>
                <li class="toc_level-2 toc_section-3">
                  <a href="#tocAnchor-1-1-2"><span class="tocnumber">1.2</span> <span class="toctext">疑问</span></a>
                </li>
              </ul>
            </li>
            <li class="toc_level-1 toc_section-4">
              <a href="#tocAnchor-1-4"><span class="tocnumber">2</span> <span class="toctext">三进制模拟</span></a>
            </li>
            <li class="toc_level-1 toc_section-5">
              <a href="#tocAnchor-1-5"><span class="tocnumber">3</span> <span class="toctext">直方图最大矩形</span></a>
              <ul>
                <li class="toc_level-2 toc_section-6">
                  <a href="#tocAnchor-1-5-1"><span class="tocnumber">3.1</span> <span class="toctext">怎样证明这个算法</span></a>
                </li>
              </ul>
            </li>
            <li class="toc_level-1 toc_section-7">
              <a href="#tocAnchor-1-7"><span class="tocnumber">4</span> <span class="toctext">二叉树中的最大路径和</span></a>
            </li>
            <li class="toc_level-1 toc_section-8">
              <a href="#tocAnchor-1-8"><span class="tocnumber">5</span> <span class="toctext">java的泛型类型兼容问题</span></a>
            </li>
            <li class="toc_level-1 toc_section-9">
              <a href="#tocAnchor-1-9"><span class="tocnumber">6</span> <span class="toctext">java 数组排序</span></a>
              <ul>
                <li class="toc_level-2 toc_section-10">
                  <a href="#tocAnchor-1-9-1"><span class="tocnumber">6.1</span> <span class="toctext">使用java.util.Arrays statc 类</span></a>
                </li>
                <li class="toc_level-2 toc_section-11">
                  <a href="#tocAnchor-1-9-2"><span class="tocnumber">6.2</span> <span class="toctext">集合类，使用java.util.Collections</span></a>
                </li>
              </ul>
            </li>
            <li class="toc_level-1 toc_section-12">
              <a href="#tocAnchor-1-12"><span class="tocnumber">7</span> <span class="toctext">生成排列问题</span></a>
              <ul>
                <li class="toc_level-2 toc_section-13">
                  <a href="#tocAnchor-1-12-1"><span class="tocnumber">7.1</span> <span class="toctext">生成第k个排列，排列按照从小到大的顺序 1、2、3 –&gt; 3、2、1</span></a>
                </li>
                <li class="toc_level-2 toc_section-14">
                  <a href="#tocAnchor-1-12-2"><span class="tocnumber">7.2</span> <span class="toctext">根据序列求序号</span></a>
                </li>
                <li class="toc_level-2 toc_section-15">
                  <a href="#tocAnchor-1-12-3"><span class="tocnumber">7.3</span> <span class="toctext">生成正向的排列 –&gt; 生成下一个排列</span></a>
                </li>
                <li class="toc_level-2 toc_section-16">
                  <a href="#tocAnchor-1-12-4"><span class="tocnumber">7.4</span> <span class="toctext">生成正向排列，有重复元素</span></a>
                </li>
                <li class="toc_level-2 toc_section-17">
                  <a href="#tocAnchor-1-12-5"><span class="tocnumber">7.5</span> <span class="toctext">生成反向序列 –&gt; 和上面基本一样，重复元素也可使用</span></a>
                </li>
              </ul>
            </li>
            <li class="toc_level-1 toc_section-18">
              <a href="#tocAnchor-1-18"><span class="tocnumber">8</span> <span class="toctext">装水容器</span></a>
            </li>
            <li class="toc_level-1 toc_section-19">
              <a href="#tocAnchor-1-19"><span class="tocnumber">9</span> <span class="toctext">回文</span></a>
              <ul>
                <li class="toc_level-2 toc_section-20">
                  <a href="#tocAnchor-1-19-1"><span class="tocnumber">9.1</span> <span class="toctext">最长回文子串</span></a>
                </li>
                <li class="toc_level-2 toc_section-21">
                  <a href="#tocAnchor-1-19-2"><span class="tocnumber">9.2</span> <span class="toctext">回文分割</span></a>
                </li>
                <li class="toc_level-2 toc_section-22">
                  <a href="#tocAnchor-1-19-3"><span class="tocnumber">9.3</span> <span class="toctext">回文分割次数最少</span></a>
                </li>
              </ul>
            </li>
            <li class="toc_level-1 toc_section-23">
              <a href="#tocAnchor-1-23"><span class="tocnumber">10</span> <span class="toctext">字典树</span></a>
            </li>
            <li class="toc_level-1 toc_section-24">
              <a href="#tocAnchor-1-24"><span class="tocnumber">11</span> <span class="toctext">ugly number</span></a>
              <ul>
                <li class="toc_level-2 toc_section-25">
                  <a href="#tocAnchor-1-24-1"><span class="tocnumber">11.1</span> <span class="toctext">判断是否为ugly number</span></a>
                </li>
                <li class="toc_level-2 toc_section-26">
                  <a href="#tocAnchor-1-24-2"><span class="tocnumber">11.2</span> <span class="toctext">求第n个ugly number</span></a>
                </li>
              </ul>
            </li>
            <li class="toc_level-1 toc_section-27">
              <a href="#tocAnchor-1-27"><span class="tocnumber">12</span> <span class="toctext">乐色</span></a>
            </li>
            <li class="toc_level-1 toc_section-28">
              <a href="#tocAnchor-1-28"><span class="tocnumber">13</span> <span class="toctext">有关一次丢番图方程的问题</span></a>
              <ul>
                <li class="toc_level-2 toc_section-29">
                  <a href="#tocAnchor-1-28-1"><span class="tocnumber">13.1</span> <span class="toctext">完美平方的问题</span></a>
                </li>
              </ul>
            </li>
            <li class="toc_level-1 toc_section-30">
              <a href="#tocAnchor-1-30"><span class="tocnumber">14</span> <span class="toctext">强盗抢劫第三题</span></a>
            </li>
            <li class="toc_level-1 toc_section-31">
              <a href="#tocAnchor-1-31"><span class="tocnumber">15</span> <span class="toctext">跳跃数的问题</span></a>
            </li>
            <li class="toc_level-1 toc_section-32">
              <a href="#tocAnchor-1-32"><span class="tocnumber">16</span> <span class="toctext">匹配</span></a>
              <ul>
                <li class="toc_level-2 toc_section-33">
                  <a href="#tocAnchor-1-32-1"><span class="tocnumber">16.1</span> <span class="toctext">通配符</span></a>
                </li>
                <li class="toc_level-2 toc_section-34">
                  <a href="#tocAnchor-1-32-2"><span class="tocnumber">16.2</span> <span class="toctext">正规</span></a>
                </li>
              </ul>
            </li>
            <li class="toc_level-1 toc_section-35">
              <a href="#tocAnchor-1-35"><span class="tocnumber">17</span> <span class="toctext">合并k个链表</span></a>
            </li>
            <li class="toc_level-1 toc_section-36">
              <a href="#tocAnchor-1-36"><span class="tocnumber">18</span> <span class="toctext">想法</span></a>
            </li>
            <li class="toc_level-1 toc_section-37">
              <a href="#tocAnchor-1-37"><span class="tocnumber">19</span> <span class="toctext">表达式</span></a>
            </li>
            <li class="toc_level-1 toc_section-38">
              <a href="#tocAnchor-1-38"><span class="tocnumber">20</span> <span class="toctext">调整数字的最小代价</span></a>
              <ul>
                <li class="toc_level-2 toc_section-39">
                  <a href="#tocAnchor-1-38-1"><span class="tocnumber">20.1</span> <span class="toctext">代码</span></a>
                </li>
                <li class="toc_level-2 toc_section-40">
                  <a href="#tocAnchor-1-38-2"><span class="tocnumber">20.2</span> <span class="toctext">思路 使用动态规划</span></a>
                </li>
                <li class="toc_level-2 toc_section-41">
                  <a href="#tocAnchor-1-38-3"><span class="tocnumber">20.3</span> <span class="toctext">expand</span></a>
                </li>
                <li class="toc_level-2 toc_section-42">
                  <a href="#tocAnchor-1-38-4"><span class="tocnumber">20.4</span> <span class="toctext">动态规划的递推数组</span></a>
                </li>
                <li class="toc_level-2 toc_section-43">
                  <a href="#tocAnchor-1-38-5"><span class="tocnumber">20.5</span> <span class="toctext">总结</span></a>
                </li>
              </ul>
            </li>
            <li class="toc_level-1 toc_section-44">
              <a href="#tocAnchor-1-44"><span class="tocnumber">21</span> <span class="toctext">背包问题</span></a>
            </li>
            <li class="toc_level-1 toc_section-45">
              <a href="#tocAnchor-1-45"><span class="tocnumber">22</span> <span class="toctext">有多少个点在同一条直线上</span></a>
              <ul>
                <li class="toc_level-2 toc_section-46">
                  <a href="#tocAnchor-1-45-1"><span class="tocnumber">22.1</span> <span class="toctext">不应使用浮点数作为map的key</span></a>
                </li>
                <li class="toc_level-2 toc_section-47">
                  <a href="#tocAnchor-1-45-2"><span class="tocnumber">22.2</span> <span class="toctext">Double key in HashMap 解法</span></a>
                </li>
              </ul>
            </li>
            <li class="toc_level-1 toc_section-48">
              <a href="#tocAnchor-1-48"><span class="tocnumber">23</span> <span class="toctext">ksum 问题</span></a>
              <ul>
                <li class="toc_level-2 toc_section-49">
                  <a href="#tocAnchor-1-48-1"><span class="tocnumber">23.1</span> <span class="toctext">深度搜索</span></a>
                </li>
                <li class="toc_level-2 toc_section-50">
                  <a href="#tocAnchor-1-48-2"><span class="tocnumber">23.2</span> <span class="toctext">动态规划</span></a>
                </li>
              </ul>
            </li>
            <li class="toc_level-1 toc_section-51">
              <a href="#tocAnchor-1-51"><span class="tocnumber">24</span> <span class="toctext">最小子数组和</span></a>
            </li>
            <li class="toc_level-1 toc_section-52">
              <a href="#tocAnchor-1-52"><span class="tocnumber">25</span> <span class="toctext">木材切割</span></a>
            </li>
            <li class="toc_level-1 toc_section-53">
              <a href="#tocAnchor-1-53"><span class="tocnumber">26</span> <span class="toctext">排序矩阵中kth -&gt; 这里</span></a>
            </li>
            <li class="toc_level-1 toc_section-54">
              <a href="#tocAnchor-1-54"><span class="tocnumber">27</span> <span class="toctext">删除数字</span></a>
            </li>
            <li class="toc_level-1 toc_section-55">
              <a href="#tocAnchor-1-55"><span class="tocnumber">28</span> <span class="toctext">留待解决的几个棘手问题</span></a>
              <ul>
                <li class="toc_level-2 toc_section-56">
                  <a href="#tocAnchor-1-55-1"><span class="tocnumber">28.1</span> <span class="toctext">买卖股票第四题</span></a>
                </li>
                <li class="toc_level-2 toc_section-57">
                  <a href="#tocAnchor-1-55-2"><span class="tocnumber">28.2</span> <span class="toctext">Burst Balloons</span></a>
                </li>
                <li class="toc_level-2 toc_section-58">
                  <a href="#tocAnchor-1-55-3"><span class="tocnumber">28.3</span> <span class="toctext">书籍复印。。。</span></a>
                </li>
                <li class="toc_level-2 toc_section-59">
                  <a href="#tocAnchor-1-55-4"><span class="tocnumber">28.4</span> <span class="toctext">统计比自己前面小的数个数，(最后一个大数据超时过不了，有490k的数组)</span></a>
                </li>
                <li class="toc_level-2 toc_section-60">
                  <a href="#tocAnchor-1-55-5"><span class="tocnumber">28.5</span> <span class="toctext">最大数字</span></a>
                </li>
                <li class="toc_level-2 toc_section-61">
                  <a href="#tocAnchor-1-55-6"><span class="tocnumber">28.6</span> <span class="toctext">最小数字</span></a>
                </li>
                <li class="toc_level-2 toc_section-62">
                  <a href="#tocAnchor-1-55-7"><span class="tocnumber">28.7</span> <span class="toctext">删除数字</span></a>
                </li>
                <li class="toc_level-2 toc_section-63">
                  <a href="#tocAnchor-1-55-8"><span class="tocnumber">28.8</span> <span class="toctext">通配符匹配</span></a>
                </li>
                <li class="toc_level-2 toc_section-64">
                  <a href="#tocAnchor-1-55-9"><span class="tocnumber">28.9</span> <span class="toctext"> 排列序号 有重复的情况(198)</span></a>
                </li>
                <li class="toc_level-2 toc_section-65">
                  <a href="#tocAnchor-1-55-10"><span class="tocnumber">28.10</span> <span class="toctext">为0的子矩阵 405 -&gt; 算法</span></a>
                </li>
                <li class="toc_level-2 toc_section-66">
                  <a href="#tocAnchor-1-55-11"><span class="tocnumber">28.11</span> <span class="toctext">停车场 489</span></a>
                </li>
                <li class="toc_level-2 toc_section-67">
                  <a href="#tocAnchor-1-55-12"><span class="tocnumber">28.12</span> <span class="toctext">迷你推特 501</span></a>
                </li>
                <li class="toc_level-2 toc_section-68">
                  <a href="#tocAnchor-1-55-13"><span class="tocnumber">28.13</span> <span class="toctext">大楼轮廓 131</span></a>
                </li>
              </ul>
            </li>
          </ul>
        </td>
      </tr>
    </tbody>
  </table>
</div><p>基本做完leetcode的题目（还剩3道，感觉题目很无厘头），其中有很多不会做参考别人的，做完很值得记下来的。一并总结</p>

<!-- more -->

<h1 id="tocAnchor-1-1">统计数组中的出现次数最多的数字</h1>

<p>如果最多数字是多于一半的，可以使用<a href="http://www.cs.utexas.edu/users/moore/best-ideas/mjrty/index.html">这个算法</a></p>

<p>也就是 一下三种情况走一遍</p>

<ul>
  <li>如果计数为0，更换为当前数字，+1  continue</li>
  <li>相同时增加计数 continue</li>
  <li>不同时减去计数 continue</li>
</ul>

<h2 id="tocAnchor-1-1-1">如果没有限制，只是找出次数最多的数字？</h2>

<ul>
  <li>使用map辅助 记录次数</li>
</ul>

<div class="language-java highlighter-rouge">
  <div class="highlight">
    <pre class="highlight">
      <code><span class="kd">private</span> <span class="kt">int</span> <span class="n">n1</span><span class="o">,</span> <span class="n">t1</span><span class="o">,</span> <span class="n">n2</span><span class="o">,</span> <span class="n">t2</span><span class="o">;</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">selecttop2</span><span class="o">(</span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="n">t1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> 
    <span class="n">n2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">t2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">n1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">t1</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">n2</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">t2</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">t1</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">t2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">t1</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">t2</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>


</code>
    </pre>
  </div>
</div>
<p>统计得到的数字n1 n2是最多的两个，t1 t2并不反映次数</p>

<h2 id="tocAnchor-1-1-2">疑问</h2>

<p>http://www.lintcode.com/zh-cn/problem/majority-number-iii/#</p>

<p>如果选出出现次数最多的数字，和k就无关？</p>

<h1 id="tocAnchor-1-4">
  <a href="http://www.lintcode.com/zh-cn/problem/single-number-ii/">三进制模拟</a>
</h1>

<p>三进制下抑或运算的模拟</p>

<p>能否继续推广？</p>

<h1 id="tocAnchor-1-5">直方图最大矩形</h1>

<div class="language-java highlighter-rouge">
  <div class="highlight">
    <pre class="highlight">
      <code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">largestRectangleArea</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">height</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// write your code here</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">height</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">height</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">area</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">empty</span><span class="o">()</span> <span class="o">||</span> <span class="n">height</span><span class="o">[</span> <span class="n">st</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">]</span> <span class="o">&lt;=</span> <span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">st</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">i</span><span class="o">++);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">height</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">*</span> <span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">empty</span><span class="o">()</span> <span class="o">?</span> <span class="n">i</span> <span class="o">:</span> <span class="n">i</span> <span class="o">-</span> <span class="n">st</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span> 
            <span class="n">res</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">area</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">st</span><span class="o">.</span><span class="na">empty</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span> <span class="c1">//总是取左侧低的</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">height</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">*</span> <span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">empty</span><span class="o">()</span> <span class="o">?</span> <span class="n">i</span> <span class="o">:</span> <span class="n">i</span> <span class="o">-</span> <span class="n">st</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span> 
        <span class="n">res</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">area</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code>
    </pre>
  </div>
</div>

<h2 id="tocAnchor-1-5-1">怎样证明这个算法</h2>

<ul>
  <li>
    <p>这个stack性质
  总是保持高度递增的
  而两个位置之间的柱体都高于</p>
  </li>
  <li>在stack中维持一个递增的直方图序列(一般保存下标)，当前处理第i个柱体
    <ul>
      <li>[i]比stack顶部高, 就push, 保持性质。</li>
      <li>[i]比stack顶部低, 依次pop并计算, 直到顶部比[i]小，然后将[i]加入
        <ul>
          <li>对stack中每一个点 计算[top,  i)区间上的大矩形面积，而其中top位置的柱体是最低的(增高的stack) i点的高度往往过低</li>
        </ul>
      </li>
      <li>i取到结尾之后，如果stack不空，就依次pop</li>
    </ul>
  </li>
  <li>具体解析
    <ul>
      <li>height[j]是当前stack的顶部柱体的高度，这个柱体和右侧，就是之前被pop出的，直到柱体[i]，构成一个矩形，最低高度为height[j],宽度为 [j, j + 1, …. i)</li>
    </ul>
  </li>
</ul>

<h1 id="tocAnchor-1-7">二叉树中的最大路径和</h1>

<p>http://www.lintcode.com/zh-cn/problem/binary-tree-maximum-path-sum/</p>

<p>从左支顶点起，一直降到leaf，选一条最大和path，右支同样，左右加上root点的值就是总体上，包含了root点的最大路径</p>

<p>每个点下降到leaf，的最大和，是可以重复利用的，只需要计算两个子节点的root-leaf最大路径 选一个大的</p>

<p>所以就可以针对计算root-leaf的最大路径，构造递归，并把原问题的解看成是一个附带计算的步骤</p>

<p>意外情况，路径的数值可能是负数，那么最后就只去一点的值即可</p>

<h1 id="tocAnchor-1-8">java的泛型类型兼容问题</h1>

<p>List&lt;List<integer>&gt; list = new ArrayList&lt;ArrayList<integer>&gt;()</integer></integer></p>

<p>java的泛型不是逆变和协变的: https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)</p>

<p>可以这样使用
List&lt;List<integer>&gt; res = new ArrayList&lt;List<integer>&gt;();</integer></integer></p>

<p>ArrayList<integer> it = new ArrayList<integer>();
res.add(it);</integer></integer></p>

<h1 id="tocAnchor-1-9">java 数组排序</h1>

<p>针对基本类型数组和集合类</p>

<h2 id="tocAnchor-1-9-1">使用java.util.Arrays statc 类</h2>

<p>默认自然升序，例如： Arrays.sort(num);</p>

<p>要进行降序，需要传入比较方法。自然降序，可以使用已有的：java.util.Collections.reverseOrder()。或者自己实现；</p>

<h2 id="tocAnchor-1-9-2">集合类，使用java.util.Collections</h2>

<p>类似于 Collections.sort(arraylist, new Comparator&lt;&gt;(){<br />
    public int compare ….<br />
});</p>

<h1 id="tocAnchor-1-12">生成排列问题</h1>

<h2 id="tocAnchor-1-12-1">生成第k个排列，排列按照从小到大的顺序 1、2、3 –&gt; 3、2、1</h2>
<p>用k不断的除 取余数，对于排列的小区间的个数（1，2，3的排列小区间就是以1开头的排列的个数）</p>

<p>例如 1，2，3，4，5，6 个数字第620个排列
k : 当期那序数 620
n ：当期那个数  6</p>

<p>先 –k 从0计数
当前数字从零数第 k / (n-1)!个
then : k &lt; – k % (n-1)!
       n &lt; – n - 1
       从固有序列中消去已经取出的字母
循环条件是k &gt; 0</p>

<div class="highlighter-rouge">
  <div class="highlight">
    <pre class="highlight">
      <code>123456      12345      2345       234       34        3  
619/5! -- &gt; 19/4! -- &gt; 19/3! -- &gt; 1/2! -- &gt; 1/1! -- &gt; 0
5:6         0:1        3:5        0:2       1:4       0:3
</code>
    </pre>
  </div>
</div>

<p>615243</p>

<p>如何解决重复数字</p>

<h2 id="tocAnchor-1-12-2">根据序列求序号</h2>

<p>和上面的反着做</p>

<ul>
  <li>有重复的？</li>
</ul>

<h2 id="tocAnchor-1-12-3">生成正向的排列 –&gt; 生成下一个排列</h2>

<ul>
  <li>从尾部到前面找到第一个[i] &lt; [i + 1]
    <ul>
      <li>如果i已经到达前面的尽头 -1，说明这时候是一个完全逆序排列，可以直接给反序结果</li>
      <li>如果没有到达-1，从 (i, 尾部) 找第一个 j 使得[i] &lt; [j]， 交换[i],[j]</li>
    </ul>
  </li>
  <li>将i + 1之后的元素全部反序</li>
</ul>

<h2 id="tocAnchor-1-12-4">生成正向排列，有重复元素</h2>
<p>上面的办法可以正常使用</p>

<h2 id="tocAnchor-1-12-5">生成反向序列 –&gt; 和上面基本一样，重复元素也可使用</h2>
<ul>
  <li>从尾部向前找[i] &gt;  [i + 1]
    <ul>
      <li>如果i已经到达前面的尽头 -1，说明这时候是一个完全逆序排列</li>
      <li>如没有到-1，从尾部向前找第一个j使得 [i] &gt; [j] 交换[i],[j]</li>
    </ul>
  </li>
  <li>将 i + 1之后的元素都反序</li>
</ul>

<h1 id="tocAnchor-1-18">装水容器</h1>

<p>http://www.lintcode.com/zh-cn/problem/container-with-most-water/</p>

<div class="language-java highlighter-rouge">
  <div class="highlight">
    <pre class="highlight">
      <code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxArea</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">heights</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">heights</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">heights</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">heights</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">heights</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">heights</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">*</span> <span class="o">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="o">));</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">heights</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">heights</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">else</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code>
    </pre>
  </div>
</div>

<h1 id="tocAnchor-1-19">回文</h1>

<h2 id="tocAnchor-1-19-1">最长回文子串</h2>

<p>线性做法，添加额外字符串</p>

<ul>
  <li>确定一个当前覆盖范围最大的回文</li>
  <li>当前处理位置在 大回文 的右侧内部 根据左侧对称点的半径和大回文右边界，从+1的位置开始搜索，</li>
  <li>当前处理位置已经到达或超出了 大回文的右侧边界点，相当于取0，从+1位置搜索，更换大回文</li>
</ul>

<p>想清楚，一个点的半径代表串延伸到哪里</p>

<h2 id="tocAnchor-1-19-2">回文分割</h2>

<ul>
  <li>合并到下一个问题中，基于第一次dp</li>
  <li>基于dfs搜索</li>
</ul>

<h2 id="tocAnchor-1-19-3">回文分割次数最少</h2>

<p>两次动态规划</p>

<ul>
  <li>第一次dp 计算任意字符串[i,j]是否是回文</li>
  <li>第二次dp 计算次数(合并在第一次中)</li>
</ul>

<div class="language-java highlighter-rouge">
  <div class="highlight">
    <pre class="highlight">
      <code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">minCut</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

    <span class="kt">boolean</span> <span class="o">[][]</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">m</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
    <span class="n">m</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">--)</span> <span class="o">{</span>
        <span class="n">m</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">m</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span> <span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                
                <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>  <span class="o">{</span>
                    <span class="n">m</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">m</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">m</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">m</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">m</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">m</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
<span class="o">}</span>
</code>
    </pre>
  </div>
</div>
<p>f(i,j)是回文，有两种情况</p>
<ul>
  <li>单个字符</li>
  <li>f[i + 1, j - 1] 是回文，而且i,处的字符也相等，极限状况是(j, j-1)这个也算作真</li>
</ul>

<h1 id="tocAnchor-1-23">字典树</h1>

<div class="language-java highlighter-rouge">
  <div class="highlight">
    <pre class="highlight">
      <code><span class="kd">class</span> <span class="nc">TrieNode</span> <span class="o">{</span>
    <span class="c1">// Initialize your data structure here.</span>
    <span class="kd">public</span>  <span class="n">String</span> <span class="n">label</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="kd">public</span> <span class="n">TrieNode</span><span class="o">[]</span> <span class="n">children</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="kd">public</span>  <span class="nf">TrieNode</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Trie</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">TrieNode</span> <span class="n">root</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Trie</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TrieNode</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// Inserts a word into the trie.</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">word</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

        <span class="n">TrieNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">node</span><span class="o">.</span><span class="na">children</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TrieNode</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TrieNode</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TrieNode</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">node</span><span class="o">.</span><span class="na">label</span> <span class="o">=</span> <span class="n">word</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Returns if the word is in the trie.</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">search</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">TrieNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">label</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="na">label</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Returns if there is any word in the trie</span>
    <span class="c1">// that starts with the given prefix.</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">startsWith</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">TrieNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code>
    </pre>
  </div>
</div>

<h1 id="tocAnchor-1-24">ugly number</h1>

<p>限定的质因子</p>

<h2 id="tocAnchor-1-24-1">判断是否为ugly number</h2>

<ul>
  <li>在限定的质因子范围内，挨个除法，直到不含，换下一个因子，最后应该等于1</li>
  <li>可以除掉一个质因子后，在新数字上递归</li>
</ul>

<h2 id="tocAnchor-1-24-2">求第n个ugly number</h2>

<p>primes:  [p1,  p1  ….  pn]
weight:   w1   w2        wn   对应的指数</p>

<div class="language-java highlighter-rouge">
  <div class="highlight">
    <pre class="highlight">
      <code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">nthSuperUglyNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">primes</span><span class="o">)</span> <span class="o">{</span> 
    <span class="k">if</span> <span class="o">(</span><span class="n">primes</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>

    <span class="kt">int</span><span class="o">[]</span> <span class="n">w</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">primes</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">u</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="n">u</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">primes</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span>  <span class="n">w</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> 
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">u</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">[</span><span class="n">w</span><span class="o">[</span><span class="mi">0</span><span class="o">]]</span> <span class="o">*</span> <span class="n">primes</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">primes</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">u</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">u</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">u</span><span class="o">[</span><span class="n">w</span><span class="o">[</span><span class="n">j</span><span class="o">]]</span> <span class="o">*</span> <span class="n">primes</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">primes</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">u</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">u</span><span class="o">[</span><span class="n">w</span><span class="o">[</span><span class="n">j</span><span class="o">]]</span> <span class="o">*</span> <span class="n">primes</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> 
                <span class="n">w</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">u</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
<span class="o">}</span>

</code>
    </pre>
  </div>
</div>

<h1 id="tocAnchor-1-27">乐色</h1>

<ul>
  <li>博弈类型</li>
  <li>邻接矩阵的性质</li>
  <li>克隆图</li>
  <li>格雷码
  对于一个数字<code class="highlighter-rouge">i -- &gt; i ^ (i &gt;&gt; 1)</code>就是一个生成格雷码</li>
</ul>

<h1 id="tocAnchor-1-28">有关一次丢番图方程的问题</h1>

<p>n元一次、整系数等式，右边也是整数常数 a1x1 + a2x2 + ….. + anxn = c</p>

<p>有整数解得充要条件：</p>

<ul>
  <li>系数的最大公约数 gcd(A) 必须是c的因子</li>
  <li>所以系数互质必然有解，整数解</li>
</ul>

<p>特别的对于二元一次 ax + by = c, gcdab|c, 设有解 x1, y1:</p>

<ul>
  <li>x = x1 + b/gcdab * t</li>
  <li>y = y1 + z/gcdab * t</li>
  <li>t是任意整数</li>
</ul>

<h2 id="tocAnchor-1-28-1">完美平方的问题</h2>

<p>系数是平方数，常数是n，互质必然有解，求解的分量和，使最小</p>

<div class="language-java highlighter-rouge">
  <div class="highlight">
    <pre class="highlight">
      <code><span class="kd">private</span> <span class="kt">int</span> <span class="n">min</span><span class="o">;</span>
<span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">sq</span><span class="o">;</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">numSquares</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="n">sq</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">N</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">sq</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">this</span><span class="o">.</span><span class="na">min</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="n">N</span><span class="o">);</span>
    <span class="n">dfs</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">min</span><span class="o">;</span>
<span class="o">}</span>


<span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">target</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">target</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">min</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">count</span><span class="o">);</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">min</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">sq</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">sq</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">//仍从原地开始，表示可以重复使用</span>
    <span class="o">}</span>
<span class="o">}</span>
</code>
    </pre>
  </div>
</div>

<p>剪枝的过程</p>

<p>计算437 的个数
原来，sq使用arraylist, 采用从小到大搜索，没有count&gt;= min限制，没有continue
最开始的搜索方法达到9.92s</p>

<ul>
  <li>list改为数组 1.26s–&gt; 1.03秒</li>
  <li>改从大到小搜索 –&gt;095s</li>
  <li>加上continue结束，没什么变化</li>
  <li>加上count&gt;=min结束条件， –&gt; 0.11s</li>
</ul>

<p>一点说明，Math.max(5, N);这个涉及到 k平方及之前的平方数，最大能组成什么数字，而且不能越过k+1的平方</p>

<p>不要超过k平方的2(k + 1), 否则就可以使用k+1平方</p>

<div class="highlighter-rouge">
  <div class="highlight">
    <pre class="highlight">
      <code>k    k*k     2(k + 1)    
1    1       4  
2    4       6  
3    9       8   
4    16      10  
5    25      12  
</code>
    </pre>
  </div>
</div>

<p>问题就出在小数字时，min设置最大为N会提前结束，而大数字因为平方根比较大，不存在此问题，测试发现5比较合适</p>

<p>仍需要进一步检查原因。。。</p>

<h1 id="tocAnchor-1-30">强盗抢劫第三题</h1>

<p>使用hash表跟踪每一个子树的最大值，需要分为取或者不取root点值</p>

<h1 id="tocAnchor-1-31">跳跃数的问题</h1>

<ul>
  <li>
    <p>解法一 使用dfs，从每个点开始向前进，失败时回溯</p>
  </li>
  <li>
    <p>解法二 使用bfs，一层一层的向前推进，需要使用到hash表，集合等，也不省空间</p>
  </li>
  <li>
    <p>解法三 使用dp，记录到某一个点时最小的步数，以后更新，直选小的</p>
  </li>
  <li>
    <p>解法四 使用一个记录rm，表示当前所能到达的最右端，然后在当前位置和最右端不断地扫描，增加最右的右边界，这个解法，最快最省空间，但是不能解决最小步数问题。</p>
  </li>
</ul>

<h1 id="tocAnchor-1-32">匹配</h1>

<h2 id="tocAnchor-1-32-1">通配符</h2>

<p>可以使用和正规相同的方法，但是测试的数据比较大，会超时，wild*匹配会比较高效，有更好的实现</p>

<h2 id="tocAnchor-1-32-2">正规</h2>

<div class="language-java highlighter-rouge">
  <div class="highlight">
    <pre class="highlight">
      <code><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isMatch2</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">spos</span><span class="o">,</span> <span class="n">String</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">ppos</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">si</span> <span class="o">=</span> <span class="n">spos</span><span class="o">,</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">ppos</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">pi</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">si</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pi</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pi</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'*'</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">do</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">isMatch2</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">si</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">pi</span> <span class="o">+</span> <span class="mi">2</span><span class="o">))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">si</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">while</span> <span class="o">(</span> <span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pi</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'.'</span> <span class="o">|</span>  <span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pi</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">si</span><span class="o">++));</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pi</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">si</span><span class="o">)</span> <span class="o">||</span> <span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pi</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'.'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">pi</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">si</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span> 
    <span class="k">return</span> <span class="n">si</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">pi</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
<span class="o">}</span>
</code>
    </pre>
  </div>
</div>

<p>主要部分理解，取一个向前看符号 pi+1位置 是否等于 *</p>

<ul>
  <li>等于*时，按照匹配了0, 1, 2 。。。进行递归匹配
    <ul>
      <li>0:   si      –&gt; pi + 2</li>
      <li>1:   si + 1  –&gt; pi + 2</li>
      <li>2:   si + 2  –&gt; pi + 2</li>
    </ul>
  </li>
  <li>
    <p>不等于*时，简单检查当前pi和si位置是否相等或.等</p>
  </li>
  <li>上面的算法中用到了java不短路的逻辑或|， 可以替代</li>
  <li>注意越界的检查</li>
</ul>

<h1 id="tocAnchor-1-35">合并k个链表</h1>

<p>每次取当前组内的最小点，合并到现有链表中，关键点是：</p>

<ul>
  <li>怎样能快速找到最小点</li>
  <li>取完这个最小点后，怎样保持性质？只有一个点是不合顺序</li>
</ul>

<p>如果使用数组排序，取完一个点保持性质，就需要移动。查找位置二分最快达到lgn，但是位置分布是不确定的，哪里都有可能，平均就在数组中间，每次要移动n/2个节点</p>

<p>使用链表，可以避免调整位置时对其他点的颠簸，但是位置查找又达到n/2</p>

<p>使用小堆是一种比较搞笑的选择。</p>

<ul>
  <li>查找和位置调整是同一个过程</li>
  <li>总体最大复杂度是lgn</li>
  <li>大小堆是满二叉查找树</li>
</ul>

<p>要使用的两个小算法</p>

<ul>
  <li>将堆顶部的不合性质的点，调整/rise到适当位置，以保持性质
    <ul>
      <li>选较son中小那一个的，交换</li>
      <li>在新的son位置上，继续调整。可以递归，不过这个是个尾递归，可以化简为没有stack的循环</li>
    </ul>
  </li>
  <li>将一个数组变成堆
    <ul>
      <li>中n/2位置开始，这个位置，作为fa，son处于数组的末尾</li>
      <li>不断的应用上面的算法</li>
    </ul>
  </li>
</ul>

<h1 id="tocAnchor-1-36">想法</h1>

<p>有一个题提交出错，但感觉不是大的错误，估计是哪个细节，就去leetcode的同一个问题看，当时是怎么做的，结果发现两次写的算法几乎完全一致，包括思路，步骤，临时变量取名，只是返回值出了点问题应该是返回平方结果返回root。 人的思路真的很相似吗。。。</p>

<h1 id="tocAnchor-1-37">表达式</h1>

<p>擦 今天让表达树问题给坑着了，气死了</p>

<p>表达式转化为逆波兰， 转化为表达树，以及求值，第一个是关键</p>

<div class="language-java highlighter-rouge">
  <div class="highlight">
    <pre class="highlight">
      <code>
<span class="kd">public</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">convertToRPN</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">expression</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Stack</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
    <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">post</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="nl">s:</span> <span class="n">expression</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">order</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">post</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"("</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">st</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">")"</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">st</span><span class="o">.</span><span class="na">peek</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"("</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">post</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
            <span class="o">}</span> <span class="n">st</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">order</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="n">order</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">peek</span><span class="o">()))</span> <span class="o">{</span>
                <span class="n">post</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="n">st</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">post</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
    <span class="k">return</span> <span class="n">post</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">order</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">")"</span><span class="o">)</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"("</span><span class="o">))</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"+"</span><span class="o">)</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"-"</span><span class="o">))</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"*"</span><span class="o">)</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"/"</span><span class="o">))</span> <span class="k">return</span> <span class="mi">2</span><span class="o">;</span>
    <span class="k">return</span> <span class="mi">3</span><span class="o">;</span>
<span class="o">}</span>

</code>
    </pre>
  </div>
</div>

<p>主要思路</p>

<ul>
  <li>是数字，输出</li>
  <li>是运算符号
    <ul>
      <li>比top高: push</li>
      <li>比top相等或低: 循环pop，最后push</li>
    </ul>
  </li>
  <li>是), 一直到把（ pop出来</li>
  <li>是(, push</li>
</ul>

<p>上面的代码就是按照这个思路写出来的</p>

<h1 id="tocAnchor-1-38">调整数字的最小代价</h1>

<p>http://www.lintcode.com/zh-cn/problem/minimum-adjustment-cost/</p>

<p>给一个整数数组，调整每个数的大小，使得相邻的两个数的差小于一个给定的整数target，调整每个数的代价为调整前后的差的绝对值，求调整代价之和最小是多少。</p>

<p>对于数组[1, 4, 2, 3]和target=1，最小的调整方案是调整为[2, 3, 2, 3]，调整代价之和是2。返回2。</p>

<h2 id="tocAnchor-1-38-1">代码</h2>

<div class="language-java highlighter-rouge">
  <div class="highlight">
    <pre class="highlight">
      <code>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">MinAdjustmentCost</span><span class="o">(</span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="kt">int</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">A</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">A</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="mi">101</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//将a[0]调整到j所用的代价</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">T</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">t</span><span class="o">),</span> <span class="n">B</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">t</span><span class="o">);</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">B</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">T</span><span class="o">;</span> <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">k</span><span class="o">]);</span>
            <span class="o">}</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>

</code>
    </pre>
  </div>
</div>

<h2 id="tocAnchor-1-38-2">思路 使用动态规划</h2>

<p>dp[i][j] 表示将第i个数字，调整为j所需要话费的最小代价。可以从i + 1层的数据计算得到</p>

<p>dp[i - 1][?] 表示第A[i - 1]的最小调整代价。进一步，从？下一步调整：</p>

<ul>
  <li>已经调整为？，则下一步只能调整到两侧距离为target的范围内</li>
  <li>这个范围是 [? - target, ? + target]</li>
  <li>由于所有数字是正整数而且不超过100， 所以对区间要加限制</li>
</ul>

<p>将整体的最优解，</p>

<ul>
  <li>转化为一个规划子问题：调整i个数据所用的最小代价，形成滚动规划的基础</li>
  <li>将最优解问题转化为，求出所有可能解，然后遍历寻找</li>
</ul>

<h2 id="tocAnchor-1-38-3">expand</h2>

<p>这两种思路是主要的、常用的，有时候并不需要求出所有的解（然后遍历寻找最优），这个根据题目要求</p>

<p>对比最小消耗路径（只能向右向下走，有时候可能带有障碍），规划的特点是</p>

<ul>
  <li>优化的目标是中间路径和</li>
  <li>相似处：到达一层或一列时，计算出所有点上的最优值</li>
  <li>这个最优值只能从上边或者右边到达，本题则是一个区间，反映在最里面的循环kBT中</li>
</ul>

<h2 id="tocAnchor-1-38-4">动态规划的递推数组</h2>

<p>有时候dp的数组可以降低维度，优化空间复杂度，特别是二维的情况比较多，可以比较明显的看出来</p>

<ul>
  <li>递推公式中，下一个状态只和前一层的若干个状态有关</li>
  <li>只涉及一个外层/循环，f(i,j) = f(i - 1, 0) . f(i - 1, 1) ….f(i - 1, n -1)…</li>
</ul>

<p>这个容易看出来空间温度可以降低，但是具体的操作需要技巧：</p>

<ul>
  <li>如果 f(i,j) 的状态只和f(i - 1, *) 的 [0, j]状态有关，那么可以倒序进行计算</li>
  <li>如果超过了j那就需要开辅助空间，有可能常数个就可以，也可能需要开一个辅助数组</li>
</ul>

<p>比如这个公式,01背包的递推</p>

<p>f(i, v) = max( f(i - 1, v),  f(i - 1, v - c(i)) + w(i));</p>

<p>一层中的状态v只和小于等于v的状态有关，那么倒序计算，就不需要任何辅助空间，一维dp就可以完成。</p>

<h2 id="tocAnchor-1-38-5">总结</h2>

<p>大部分情况都是上面的两个思路，主要分清</p>

<ul>
  <li>状态转化的方程</li>
  <li>转化到当前状态时，上一个状态都有哪些。。。</li>
</ul>

<h1 id="tocAnchor-1-44">背包问题</h1>

<p><a href="http://love-oriented.com/pack/Index.html#sec4">看这里</a>的讲解比较详细</p>

<p>背包问题递推公式</p>

<div class="highlighter-rouge">
  <div class="highlight">
    <pre class="highlight">
      <code>f(i, v) = max{ f(i-1, v),  f(i-1, v-ci) + wi}
    v  对总体的限制 比如体积 限制属性和f一般不同              
    ci 取第i个物品，产生的消耗消耗: 体积 等限制             
    wi 第i个物品的价值、收益等               
    f(i, j)  前i件物品，容量为j的包 最大价值。。。
</code>
    </pre>
  </div>
</div>

<p>从一个数组中取k个数，要求和为t，求方案总数</p>

<p>物品为n个，总体积限制为t，物品个数限制为k，这是新增的限制，双重限定类型，公式为</p>

<p>f(i, ki, t) = f(i - 1, ki, t) + f(i - 1, ki - 1, t - A[i])</p>

<ul>
  <li>f(i - 1, ki, t) 表示第i个数字上没有取：上一次就已经是ki个数字，和也是t了，不用取i</li>
  <li>f(i - 1, ki - 1, t - A[i]) 表示这一次取了A[i]</li>
  <li>ki 是对应于k的限制</li>
</ul>

<p>空间优化的考虑</p>

<h1 id="tocAnchor-1-45">有多少个点在同一条直线上</h1>

<p>有一种解法，已经通过leetcode的c++，但是存在一些问题： 使用了double作为key</p>

<h2 id="tocAnchor-1-45-1">不应使用浮点数作为map的key</h2>

<p>double是不安全的数据类型，是不精确的。</p>

<p>一个数字的的code number和设想的nmber很可能就是不一样的</p>

<p>通常不应该对浮点数字做相等的比较，而是通过数字差别e，小于一定范围即可认为相等</p>

<p>但是在java的Hashtable中，不存在这样的方法。Double的hashcode是这样计算的：</p>

<div class="language-java highlighter-rouge">
  <div class="highlight">
    <pre class="highlight">
      <code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
  <span class="kt">long</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">doubleToLongBits</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
  <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">bits</span> <span class="o">^</span> <span class="o">(</span><span class="n">bits</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">32</span><span class="o">));</span>
<span class="o">}</span>
</code>
    </pre>
  </div>
</div>

<p>总之不要使用浮点作为key，那种解法是不可取的的</p>

<h2 id="tocAnchor-1-45-2">Double key in HashMap 解法</h2>

<div class="language-java highlighter-rouge">
  <div class="highlight">
    <pre class="highlight">
      <code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxPoints</span><span class="o">(</span><span class="n">Point</span><span class="o">[]</span> <span class="n">points</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">points</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">points</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">x</span> <span class="o">==</span> <span class="n">points</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">x</span> <span class="o">&amp;&amp;</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">y</span> <span class="o">==</span> <span class="n">points</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">y</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>   <span class="c1">//与i 同一个坐标</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="kt">double</span> <span class="n">s</span> <span class="o">=</span> 
                <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">x</span> <span class="o">==</span> <span class="n">points</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">x</span> <span class="o">?</span> 
                <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">:</span> 
                <span class="o">(</span><span class="kt">double</span><span class="o">)(</span><span class="n">points</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">y</span> <span class="o">-</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">y</span><span class="o">)</span> <span class="o">/</span> <span class="o">(</span><span class="n">points</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">x</span> <span class="o">-</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">x</span><span class="o">);</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">==</span> <span class="kc">false</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span> <span class="o">*</span> <span class="mf">1.0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">double</span> <span class="nl">key:</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">+</span> <span class="n">cnt</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</code>
    </pre>
  </div>
</div>

<h1 id="tocAnchor-1-48">ksum 问题</h1>

<p>整数规划 单纯型 凸优化</p>

<p>在一个数组中取k个数，要求和为target，取得方案有多少种</p>

<h2 id="tocAnchor-1-48-1">深度搜索</h2>

<p>之前一直试图用搜索，深搜无论怎么剪都超时。这个推测是类似背包的，搜索空间是弱指数的</p>

<p>主要还是：如果搜索来到同一位置、同一个kth、同样的和，就返回，但是这要求递归给返回值</p>

<p>对于剪枝的技巧还是不到位</p>

<h2 id="tocAnchor-1-48-2">动态规划</h2>

<p>用空间换时间</p>

<h3 id="分析">分析</h3>

<p>接着上面搜索的思路，要记忆一个搜索的节点，以方便下一次利用。一个搜索节点包含了3个信息</p>

<ul>
  <li>对数组哪一个数据的计算：两种策略采用它还是不采用？</li>
  <li>这个数据属于k个数据中的哪一个？</li>
  <li>计算完这个数据之后，得到的value，就是和是多少</li>
</ul>

<p>这个非常类似于背包问题，有双重的限定</p>

<!-- 对于数组中的数字，采用或者不采用，两种策略 -->

<h3 id="转移方程">转移方程：</h3>

<p>f(i, ki, t), 表示搜索完第i个数字之后，取了ki个数字(对于k)，和为t，这样的方案有f种</p>

<center>f(i, ki, t) = f(i - 1, ki, t) + f(i - 1, ki - 1, t - A[i])</center>

<p>f(i - 1, ki, t) 表示第i个数字上没有取，上一次就已经是ki个数字，和也是t了</p>

<p>f(i - 1, ki - 1, t - A[i]) 表示这一次取了A[i]</p>

<h3 id="空间优化">空间优化</h3>

<p>f有三个维度，通常就意味三重循环和三维的辅助数组，空间还可以优化</p>

<p>f(i,,)只和上一次的f(i - 1,,)有关，每次只在上一次的基础上计算就可以，可以降低到二维</p>

<center>fi (ki, t) = fi1(ki, t) + fi1(ki - 1, t - A[i])</center>

<p>计算这个二维dp上的一个点时， 需要用到本身和上一层ki - 1中的第t-A[i]个值，如果采用顺序计算，则还需要开辟常数的辅助空间进行暂存，这种情况，可以这样优化</p>

<ul>
  <li>如果计算(i, j)点的值只需要(i - 1, *) 就意味着可以减少一个维度</li>
  <li>进一步，如果*只和[0 –&gt;j]有关，那么就不需要开辅助数组，倒序计算</li>
  <li>类似的，如果只和[j –&gt; n - 1]有关，顺序计算</li>
  <li>最差的，*的返回包含了j的两侧，就需要另开暂存的空间了</li>
</ul>

<p>进一步考虑上面的第二个公式，是否可以再降维？到1</p>

<h3 id="代码-1">代码</h3>

<div class="language-java highlighter-rouge">
  <div class="highlight">
    <pre class="highlight">
      <code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">kSum</span><span class="o">(</span><span class="kt">int</span> <span class="n">A</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">A</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">A</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span>  <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kt">int</span><span class="o">[][]</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">target</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">ki</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">ki</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">ki</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">t</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">f</span><span class="o">[</span><span class="n">ki</span><span class="o">][</span><span class="n">t</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">A</span><span class="o">.</span><span class="na">length</span><span class="o">;;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">ki</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">ki</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">ki</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">t</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">ki</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">==</span> <span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">f</span><span class="o">[</span><span class="n">ki</span><span class="o">][</span><span class="n">t</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>   <span class="c1">// like seeds</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">ki</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">f</span><span class="o">[</span><span class="n">ki</span><span class="o">][</span><span class="n">t</span><span class="o">]</span> <span class="o">+=</span> <span class="n">f</span><span class="o">[</span><span class="n">ki</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">t</span> <span class="o">-</span> <span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">]];</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">f</span><span class="o">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">target</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
<span class="o">}</span>
</code>
    </pre>
  </div>
</div>
<h1 id="tocAnchor-1-51">最小子数组和</h1>

<p>很容易找到平方阶的算法，但是大数据会超时，有长达几千的数组</p>

<p>加速的办法：计算0 –&gt; i 之间的和，作成另一个数组，这样两数字差就是某一个区间的和</p>

<p>将数组排序，差值最小的就在相邻的数字间产生，最小的差值就是最小的区间和</p>

<div class="language-java highlighter-rouge">
  <div class="highlight">
    <pre class="highlight">
      <code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">subarraySumClosest</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>     <span class="c1">// time exce</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&gt;</span> <span class="n">sums</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="n">sums</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">pair</span><span class="o">(</span><span class="n">sum</span><span class="o">,</span> <span class="n">i</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">sums</span><span class="o">,</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&gt;(){</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">pair</span> <span class="n">p1</span><span class="o">,</span> <span class="n">pair</span> <span class="n">p2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">p1</span><span class="o">.</span><span class="na">x</span> <span class="o">-</span> <span class="n">p2</span><span class="o">.</span><span class="na">x</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">});</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">gap</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">sums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">x</span> <span class="o">-</span> <span class="n">sums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">).</span><span class="na">x</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="n">gap</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">gap</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">sums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">x</span> <span class="o">-</span> <span class="n">sums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">).</span><span class="na">x</span><span class="o">);</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">sums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">y</span><span class="o">,</span> <span class="n">sums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">).</span><span class="na">y</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">sums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">y</span><span class="o">,</span> <span class="n">sums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">).</span><span class="na">y</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="o">{</span><span class="n">s</span><span class="o">,</span> <span class="n">e</span><span class="o">};</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code>
    </pre>
  </div>
</div>

<h1 id="tocAnchor-1-52">木材切割</h1>

<p>从最短的长度 – 检查能切到的段数，是比较普通的办法，</p>

<p>从[1  &lt;–&gt;  minlen]的 区间中找到中间的某个值，而且对于任意i &lt; j来说，切割段数f(i) &gt; f(j)</p>

<p>这就构成了排序的特性，可以使用二分查找的办法,跳跃试探，达到快速收敛</p>

<h1 id="tocAnchor-1-53">排序矩阵中kth -&gt; <a href="http://stackoverflow.com/questions/15179536/kth-smallest-element-in-sorted-matrix">这里</a></h1>

<ul>
  <li>利用heap,先对第一行所有元素加入heap,每个元素下面同一列的元素必然比他们大重复K-1次下面的过程</li>
  <li>取现在的root</li>
  <li>将root下面的元素加入heap</li>
  <li>？ 怎么保证root的下面总是有元素可以添加？ 怎么理解。。。？</li>
</ul>

<h1 id="tocAnchor-1-54">
  <a href="http://www.cnblogs.com/easonliu/p/4507657.html">删除数字</a>
</h1>

<div class="language-cpp highlighter-rouge">
  <div class="highlight">
    <pre class="highlight">
      <code><span class="n">string</span> <span class="nf">DeleteDigits</span><span class="p">(</span><span class="n">string</span> <span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span> 
    <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">s</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
            <span class="o">++</span><span class="n">cnt</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'0'</span> <span class="o">||</span> <span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="n">s</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="n">s</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="n">cnt</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code>
    </pre>
  </div>
</div>

<ul>
  <li>把前面比自己小的数字都删去，只留下依次增大的</li>
  <li>头部不能是’0’</li>
  <li>源字符串升序比较多，会导致res过长，就按照个数切断</li>
  <li>如果是降序较多，则在删除k个时候就不会再删除了：cnt &lt; k</li>
</ul>

<h1 id="tocAnchor-1-55">留待解决的几个棘手问题</h1>

<h2 id="tocAnchor-1-55-1">买卖股票第四题</h2>

<p><a href="http://www.cnblogs.com/lishiblog/p/5695142.html">这里</a>的解法值得看</p>

<div class="language-java highlighter-rouge">
  <div class="highlight">
    <pre class="highlight">
      <code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">prices</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="o">)</span> <span class="k">return</span> <span class="n">MaxP</span><span class="o">(</span><span class="n">prices</span><span class="o">);</span>

    <span class="kt">int</span><span class="o">[][]</span> <span class="n">G</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">L</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> 
            <span class="n">G</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">L</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> 
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">gap</span> <span class="o">=</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
            <span class="n">L</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> 
            <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">G</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">gap</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="n">L</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">gap</span><span class="o">);</span>
            <span class="n">G</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">L</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">G</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>
        <span class="o">}</span>
    <span class="k">return</span> <span class="n">G</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">k</span><span class="o">];</span>
<span class="o">}</span>

<span class="kt">int</span> <span class="nf">MaxP</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> 
            <span class="n">res</span> <span class="o">+=</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code>
    </pre>
  </div>
</div>

<h2 id="tocAnchor-1-55-2">
  <a href="http://www.lintcode.com/en/problem/burst-balloons/">Burst Balloons</a>
</h2>

<h2 id="tocAnchor-1-55-3">书籍复印。。。</h2>

<h2 id="tocAnchor-1-55-4">统计比自己前面小的数个数，(最后一个大数据超时过不了，有490k的数组)</h2>

<h2 id="tocAnchor-1-55-5">
  <a href="http://www.lintcode.com/zh-cn/problem/largest-number/">最大数字</a>
</h2>

<p>给出一个数组 将里面的数字重新连接-组合 求构成的最大数字<br />
[1, 20, 23, 4, 8]，返回组合最大的整数应为8423201。</p>

<p>思路  将组合过程看成是排序，比较两个数分别在前后时，哪一个组合值更大？ 如：8-23和23-8 这样排序的结果就是 最大数字的所需要的顺序。最后需要注意的特殊情况就是全部是0</p>

<p>提交接受的方法中，这个思路是可行的，需要注意的是，怎样减少比较的开销（不要实际创建新的字符串）</p>

<div class="language-java highlighter-rouge">
  <div class="highlight">
    <pre class="highlight">
      <code><span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">ar</span><span class="o">,</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;(){</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">String</span> <span class="n">s1</span><span class="o">,</span> <span class="n">String</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//return (s2 + s1).compareTo(s1 + s2);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// s2 + s1</span>
        <span class="kt">int</span> <span class="n">c1</span><span class="o">,</span> <span class="n">c2</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">k1</span> <span class="o">&lt;</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">?</span> <span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">k1</span><span class="o">):</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">k1</span> <span class="o">-</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">k2</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">?</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">k2</span><span class="o">):</span> <span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">k2</span> <span class="o">-</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">c1</span> <span class="o">!=</span> <span class="n">c2</span><span class="o">)</span> <span class="k">return</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span><span class="o">;</span>
            <span class="n">k1</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">k2</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span>
</code>
    </pre>
  </div>
</div>

<h2 id="tocAnchor-1-55-6">
  <a href="http://www.lintcode.com/zh-cn/problem/reorder-array-to-construct-the-minimum-number/">最小数字</a>
</h2>

<p>思路是一样的 但是特殊情况： 开头的0</p>

<h2 id="tocAnchor-1-55-7">
  <a href="http://www.lintcode.com/zh-cn/problem/delete-digits/#">删除数字</a>
</h2>

<p>使用挨个列举比较 逐渐移动删除的小区间，获得删除后的数字，比较获取最小数 线性复杂度</p>

<p>[0,  i - 1] [i,  i + k - 1] [i + k,   n - 1] 每移动一次I区间得到一个n-k位数字。。。</p>

<p>for (j = 0; j &lt; i; j += 1) …<br />
for (j = i + k; j &lt; n; j += 1) …</p>

<h2 id="tocAnchor-1-55-8">
  <a href="https://leetcode.com/submissions/detail/59361698/">通配符匹配</a>
</h2>

<div class="language-c++ highlighter-rouge">
  <div class="highlight">
    <pre class="highlight">
      <code><span class="kt">bool</span> <span class="nf">isMatch</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">startFound</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">si</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>        
    <span class="kt">int</span> <span class="n">prep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pres</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sn</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">pn</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">si</span> <span class="o">&lt;</span> <span class="n">sn</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pi</span> <span class="o">&lt;</span> <span class="n">pn</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">[</span><span class="n">pi</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'*'</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">prep</span> <span class="o">=</span> <span class="o">++</span><span class="n">pi</span><span class="p">;</span>
            <span class="n">pres</span> <span class="o">=</span> <span class="n">si</span><span class="p">;</span>
            <span class="n">startFound</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pi</span> <span class="o">&lt;</span> <span class="n">pn</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">pi</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">||</span> <span class="n">p</span><span class="p">[</span><span class="n">pi</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'?'</span><span class="p">))</span> <span class="p">{</span>
                <span class="o">++</span><span class="n">pi</span><span class="p">;</span> <span class="o">++</span><span class="n">si</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">startFound</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">pi</span> <span class="o">=</span> <span class="n">prep</span><span class="p">;</span>
                <span class="n">si</span> <span class="o">=</span> <span class="o">++</span><span class="n">pres</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">pi</span> <span class="o">&lt;</span> <span class="n">pn</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">[</span><span class="n">pi</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'*'</span><span class="p">)</span> <span class="n">pi</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">pi</span> <span class="o">==</span> <span class="n">pn</span><span class="p">;</span>
<span class="p">}</span>
</code>
    </pre>
  </div>
</div>

<h2 id="tocAnchor-1-55-9"> 排列序号 有重复的情况(198)</h2>

<p>和无重复情况算法有关，提交的无重复算法和大多数人不一样。。。</p>

<h2 id="tocAnchor-1-55-10">为0的子矩阵 405 -&gt; 算法</h2>

<h2 id="tocAnchor-1-55-11">停车场 489</h2>

<h2 id="tocAnchor-1-55-12">迷你推特 501</h2>

<h2 id="tocAnchor-1-55-13">大楼轮廓 131</h2>

    </div>

    <hr>

  
    <ul class="tag_box inline">
      <li><i class="icon-folder-open"></i></li>
      
      


  
     
    	<li><a href="/categories#算法-ref">
    		算法 <span>5</span>
    	</a></li>
    
  


    </ul>
    

  
    <ul class="tag_box inline">
      <li><i class="icon-tags"></i></li>
      
      


  
     
    	<li><a href="/tags#lintcode-ref">lintcode <span>2</span> </a></li>
    
  



    </ul>
    


    <nav aria-label="Page navigation">
      
      <ul class="pagination">
      
        <li class="prev"><a href="/posts/shell%E5%B8%B8%E7%94%A8%E7%94%A8%E6%B3%95" title="shell常用用法">前一篇</a></li>
      

        <li><a href="">目录</a></li>
        
      
        <li class="next"><a href="/posts/Vultr" title="Vultr">后一篇</a></li>
      
      </ul>
    </nav>


<script type="text/javascript">
    $(document).ready(
        function expand() {
            var node = $("h1")
            for (var i = 0; i < node.length; i++) {
                var t = node[i]
                  var num = $("[href='#" + t.id + "']").children("span.tocnumber")
                  t.innerText = num.text() + "    " + t.innerText
            }

            node = $("h2")
            for (var i = 0; i < node.length; i++) {
                  var t = node[i]
                  var num = $("[href='#" + t.id + "']").children("span.tocnumber")
                  t.innerText = num.text() + "   " + t.innerText
            }

            
        }
    );
</script>
    
  </div>
</div>

      </div>
      <hr/>
      <center> <footer>
        &copy; 2019 yacc3 with help from <a href="http://jekyllrb.com" target="_blank" title="The simple, blog-aware, static site generator.">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank" title="GitHub Pages">GitHub</a>.
        <br><br>
      </footer> </center>


    </div>


  </body>
</html>

